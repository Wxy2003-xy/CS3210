\documentclass[8pt]{article}

\usepackage[a4paper, margin=0.4in]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{listings}  
\usepackage{dsfont}
\usepackage{amssymb}
\usepackage{zlmtt}
\usepackage{fancyvrb}
\lstset{
  frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  keywordstyle=\color{blue}\bfseries,       % <<<< keyword styling
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{orange},
  numbers=none,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  % If you want to highlight extra words:
  morekeywords={uint32_t,size_t,shmat,shmget, sem_t, sem_wait, sem_post, SharedMem} % add your own identifiers here
}

\setlength{\extrarowheight}{0pt}
\setlength{\parskip}{0pt}
\begin{document}
\title{Process Synchronization}
\author{@Wxy2003-xy}
\date{}
\maketitle
\section{Producer-consumer problem}
The process producing information and the process that consumes the information to be produced by the coorperating process are accessing shared memory. To run the producer and consumer processes concurrently, a buffer is used. 
\begin{itemize}
    \item Bounded buffer: a fixed size buffer, where the consumer must wait when the buffer is empty, and the producer must wait if the buffer is full. 
    \item Unbounded buffer: a buffer without fixed size, the consumer may have to wait for new items, but the producer can always produce new items. 
\end{itemize}
\subsubsection*{Protential Issue:}
When using a counter to keep track the number of items in a bounded buffer (or the size of an unbounded buffer), concurrent \texttt{produce()} and \texttt{consume()} can lead to data inconsistency, and increment/decrement operations are not atomic on the assembly level.
\subsubsection*{Critical section:}
A segment of a process that modifies shared resources e.g. global flags, shared memory. No more than 1 process can be in the critical section, i.e. no concurrent modification/access of shared resources.
\begin{itemize}
    \item Each process must request permission to enter the CS
    \item Entry section: handling request, start of a CS
    \item Exit section: the end of a CS
\end{itemize}
\subsubsection*{Requirements}
\begin{enumerate}
    \item Mutual exclusion: No concurrent execution of the critical section. 
    \item Progress: No ready process wanting to enter the CS should not be indefinitely deferred when no other processes are in the CS.
    \item Bounded wait: 
\end{enumerate}
\subsubsection*{Naive software level implementation}
\begin{minipage}{0.45\linewidth}
\begin{Verbatim}[frame=topline,numbers=left,label= Process 0,framesep=3mm]
    bool* lock = (bool*) shmat(sid, NULL, 0);
    *lock = false;

    while (!lock);
    *lock = true;
    // critical section
    *lock = false;
\end{Verbatim}
\end{minipage}\hfill
\begin{minipage}{0.45\linewidth}
\begin{Verbatim}[frame=topline,numbers=left,label= Process 1,framesep=3mm]



    while (!lock);
    *lock = true;
    // critical section
    *lock = false;
\end{Verbatim}
\end{minipage}\hfill
\par\vspace{3ex}
Problem with this implementation is that the locking and unlocking operations are not atomic.\\
\par\vspace{3ex}
\begin{minipage}{0.45\linewidth}
\begin{Verbatim}[frame=topline,numbers=left,label= Process 0,framesep=3mm]
# initialization...
loop: 
    la $t0, LOCK_ADDR
    lw $t1, $t0, 0 
    bne $t1, $0, loop
    sw $t0, 1
# Critical Section 
    la $t0, LOCK_ADDR
    sw $t0, 1
\end{Verbatim}
\end{minipage}\hfill
\begin{minipage}{0.45\linewidth}
\begin{Verbatim}[frame=topline,numbers=left,label= Process 1,framesep=3mm]

loop: 
    la $t0, LOCK_ADDR
    lw $t1, $t0, 0 
    bne $t1, $0, loop
    sw $t0, 1
# Critical Section 
    la $t0, LOCK_ADDR
    sw $t0, 1
\end{Verbatim}
\end{minipage}\hfill
\subsubsection*{Peterson's Solution}

\subsubsection*{Test and Set lock}
\begin{lstlisting}
    
\end{lstlisting}
\end{document}
